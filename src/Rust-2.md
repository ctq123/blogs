# Rust编程系列2-垃圾回收机制介绍

> 文章简介：主要介绍Rust系列的文章，本文主要介绍Rust的垃圾回收机制

## 1、垃圾回收机制
我们目前了解的GC方式一般有两种，一种是通过垃圾回收器自动回收，如JAVA、javascript等，这种的缺点也很明显，一旦GC线程启动，所有程序必须停止；

另一种是通过显式分配和释放，如C，C++等，这种的缺点也很明显，因为由程序员亲自手动分配和释放内存，那就是很容易造成内存泄漏

而Rust选择了第三种方式，通过所有权管理内存。

#### 1）所有权
所有权是Rust最独特的功能，它使Rust无需垃圾收集器即可保证内存的安全。

为什么出现所有权？因为很多管理堆栈的处理器有待优化，比如跟踪代码哪些部分使用堆，哪些使用栈，如何清理确保不会耗尽空间，而rust提出一种独特的管理堆栈的方式，那就是所有权

Rust具有独特的垃圾处理机制，通过所有权系统管理内存，该系统具有一种规则，那就是在编译时进行检查。

所有权的规则：
> 1）Rust中的每个值都有一个变量，称其为所有者
> 2）一次只能有一个所有者
> 3）当所有者超出范围时，该值将被删除

例子：
```
{
    let s1 = "hello";
    let s2 = String::from("hello"); 
    
    // do stuff with s2
}
```

上述s1和s2的值都是一样的，但在Rust中代表着不一样的意思；s1表示一个字符串字面值，是不可变的，文本硬编码进可执行的二进制文件中，读取非常的高效和快速，存在栈中；然而并非所有的字符串都是不可变的，比如需要获取用户的输入值时，就需要实时存储未知大小的字符串。而s2就是出现在这种场景中，根据String::from，它会被分配在堆上，随着程序的运行而改变。

当调用String::from时，它的实现向系统请求所需的内存，内存在拥有它的变量离开作用域后，Rust为我们调用一个特殊的函数，这个函数叫做drop，也就是Rust在结尾的“}”处自动调用drop，将内存释放

例子1：

```
{
    let x=5;
    let y=x;
}
```
将变量x的整数值赋给y，内存栈中会保留两份5的值，分别指向x和y

例子2：
```
{
    let s1=String::from('5');
    let s2=s1;
}
```
内存栈中保存s1的是一个数据结构T，它由三部分组成，一个指针，一个长度，一个容量。

将变量s1的整数值赋给s2，内存栈中保留2份数据结构T，分别指向s1和s2，但s1和s2指针指向的堆数据只有一份。

这跟其他语言的堆数据保存似乎没有什么差别，然而，由它内存释放的机制来看会出现一个问题，当就是s1和s2离开作用域时都会释放相同的内存，会出现二次释放的错误。Rust为了保证内存的安全性，即所有权，同一时刻只能有且只有一份内存，当s1尝试拷贝分配内存给s2时，Rust则认为s1不再有效，因此Rust不需要在s1离开作用域后清理任何东西。

```
{
    let s1=String::from('5');
    let s2=s1;
    
    println(s1);// 异常，s1已无效
}
```
也就是说Rust永远不会**自动创建**数据的“深拷贝”。

> 注意是自动，而不是说不支持深拷贝，其实就是减少程序员写程序过程中出现自动深拷贝改变原有数据造成的bug

如若要进行堆数据的拷贝，即深拷贝，需要手动显式调用拷贝方法

```
{
    let s1=String::from('5');
    let s2=s1.clone();
    
    println(s1);// 正常
}
```

这样，s1和s2在堆中保留两份数据

**函数参数值的传递和释放**

函数值的传递，若传递的是基本类型，不会有任何问题，若传递的是堆数据（对象或数组），那么会改变提前释放掉堆数据，进而影响原父函数的运行
```
fn main() {
  let s1 = 5;
  let s2 = String::from("5");

  call_stack(s1);
  println!("stack2 {}", s1);

  call_heap(s2);
  println!("heap2 {}", s2);// 异常，函数调用时已经释放了
}

fn call_stack(s: i32) {// copy
  println!("stack1 {}", s);
}// 释放s

fn call_heap(s: String) {// move
  println!("heap1 {}", s);
}// 释放s，释放掉了s2的堆内存
```
若要从新使用s2的话可以通过返回值从新传递给它，转移所有权
```
fn main() {
  let s2 = String::from("5");

  let s3 = call_heap(s2);
  println!("heap2 {}", s3);// 正常
}

fn call_heap(s: String) -> String {
  println!("heap1 {}", s);
  
  s // 调用drop前从新返回，相当于转移所有权
}// 释放掉s
```
之所以会提前释放掉堆内存，是由于函数的参数值获取的是原变量的所有权，除了上面的转移所有权外，还有另一种办法是引用。
